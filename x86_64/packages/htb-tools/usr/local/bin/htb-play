#!/bin/sh

appkey=$(secret-tool lookup htb-api user-htb-api)
machine_json_file="$HOME/.machine.json"
table_file="$HOME/.table.txt"

############################################################
# Banner                                                   #
############################################################

printf '%b\n' "$(base64 -d <<<"H4sIAAAAAAAAA+1buw6DMAzc+xVZWlUoSlCZqn5K+wv8/9oHUgkQIEBCDtueqlOHi+/imICVihunsL+9yqp6lo/7rb42P+t1iB1CcVjqWAzxkW3ZCtJEkH0QvU5GtGWkQ8wnyG5tu0h5g0Y/XhqME2jsEno7RHmyxVkbT9Bdbl9sV2g0rnsiymeDf9At/cZjBTSSCXfDbHx9wSghXSsQOQTnVW6jQCO/RUdaMkbLTYgP0EiLnagjU7Yk239wtbXl1FQMEd00Vp1GC41jXiT3CZRva2g5gJ2bKNbbomhysOtlTHbjE3oKWYcwb3ecM5Gf8dmXfnyk17gx9aih/JJgiBSeh1K+ygNUqZHbAtFENBFNRBPRRDQRTUSTuJoc8jLKl0VhFN8bZzR66RAs8Tp2UnQvz6zuGu4XZJ/BC0R/oSUpHeJ+ET/4GJbR9bxCEL4hccjuY7v7vA48bDe2DjG5t5yhO9hlLx5rjc/8kD1wBVncoox5ZHpMUhyUsYxNRMAILtp6otXA0RG4BcnZ4O3J+cuWwxtaDodVdT0AAA==" | gunzip)" #User printf for colored output
echo

############################################################
# Help                                                     #
############################################################
Help()
{
   # Display Help
   echo "HTB Play allows you to spawn Hack The Box machines from CLI."
   echo
   echo "$(basename "$0") [-h] [-l]"
   echo
   echo "Options:"
   echo "h     Print this Help."
   echo "l     List retired machines."
   echo "m     Specify the machine name to play."
   echo
   echo "Usage Examples:"
   echo "htb-play"
   echo "htb-play -l"
   echo "htb-play -m RouterSpace"
   echo
}

##############################################################################################
#                                       Print Table                                          #
# https://stackoverflow.com/questions/12768907/how-can-i-align-the-columns-of-tables-in-bash #
##############################################################################################

function printTable()
{
    local -r delimiter="${1}"
    local -r data="$(removeEmptyLines "${2}")"

    if [[ "${delimiter}" != '' && "$(isEmptyString "${data}")" = 'false' ]]
    then
        local -r numberOfLines="$(wc -l <<< "${data}")"

        if [[ "${numberOfLines}" -gt '0' ]]
        then
            local table=''
            local i=1

            for ((i = 1; i <= "${numberOfLines}"; i = i + 1))
            do
                local line=''
                line="$(sed "${i}q;d" <<< "${data}")"

                local numberOfColumns='0'
                numberOfColumns="$(awk -F "${delimiter}" '{print NF}' <<< "${line}")"

                # Add Line Delimiter

                if [[ "${i}" -eq '1' ]]
                then
                    table="${table}$(printf '%s#+' "$(repeatString '#+' "${numberOfColumns}")")"
                fi

                # Add Header Or Body

                table="${table}\n"

                local j=1

                for ((j = 1; j <= "${numberOfColumns}"; j = j + 1))
                do
                    table="${table}$(printf '#| %s' "$(cut -d "${delimiter}" -f "${j}" <<< "${line}")")"
                done

                table="${table}#|\n"

                # Add Line Delimiter

                if [[ "${i}" -eq '1' ]] || [[ "${numberOfLines}" -gt '1' && "${i}" -eq "${numberOfLines}" ]]
                then
                    table="${table}$(printf '%s#+' "$(repeatString '#+' "${numberOfColumns}")")"
                fi
            done

            if [[ "$(isEmptyString "${table}")" = 'false' ]]
            then
                echo -e "${table}" | column -s '#' -t | awk '/^\+/{gsub(" ", "-", $0)}1'
            fi
        fi
    fi
}

function removeEmptyLines()
{
    local -r content="${1}"

    echo -e "${content}" | sed '/^\s*$/d'
}

function repeatString()
{
    local -r string="${1}"
    local -r numberToRepeat="${2}"

    if [[ "${string}" != '' && "${numberToRepeat}" =~ ^[1-9][0-9]*$ ]]
    then
        local -r result="$(printf "%${numberToRepeat}s")"
        echo -e "${result// /${string}}"
    fi
}

function isEmptyString()
{
    local -r string="${1}"

    if [[ "$(trimString "${string}")" = '' ]]
    then
        echo 'true' && return 0
    fi

    echo 'false' && return 1
}

function trimString()
{
    local -r string="${1}"

    sed 's,^[[:blank:]]*,,' <<< "${string}" | sed 's,[[:blank:]]*$,,'
}

############################################################
#                       Progress Bar                       #
#          https://github.com/roddhjav/progressbar         #
############################################################

readonly Bold='\e[1m'
readonly Bred='\e[1;31m'
readonly Byellow='\e[1;33m'
readonly reset='\e[0m'

__die() { echo -e " ${Bred}[x]${reset} ${Bold}Error :${reset} ${*}" >&2 && exit 1; }

__progressbar_error() {
	echo "A valid ${*} must be supplied to initialise 'progressbar'."
}

__progressbar_theme() {
	[[ -z "${ILoveCandy}" ]] && ILoveCandy=false
	[[ -z "${Braket_in}" ]]  && Braket_in="["
	[[ -z "${Braket_out}" ]] && Braket_out="]"

	# Definition of the diferent cursors
	if [[ "${ILoveCandy}" == true ]]; then
		[[ -z "${Cursor_done}" ]]     && Cursor_done="-"
		[[ -z "${Cursor_not_done}" ]] && Cursor_not_done="o  "
		[[ -z "${Cursor}" ]]          && Cursor="${Byellow}C${reset}"
		[[ -z "${Cursor_small}" ]]    && Cursor_small="${Byellow}c${reset}"
	else
		[[ -z "${Cursor_done}" ]]     && Cursor_done="#"
		[[ -z "${Cursor_not_done}" ]] && Cursor_not_done="-"
	fi
}

progressbar() {
	[[ -z "${1}" ]] && __die "$(__progressbar_error bar title)"
	[[ -z "${2}" ]] && __die "$(__progressbar_error curent position)"
	local title="${1}" current="${2}" total="${3:-100}"
	local msg1="${4}" msg2="${5}" msg3="${6}"
	__progressbar_theme

	cols=$(tput cols)
	(( block=cols/3-cols/20 ))
	(( _title=block-${#title}-1 ))
	(( _msg=block-${#msg1}-${#msg2}-${#msg3}-3 ))

	_title=$(printf "%${_title}s")
	_msg=$(printf "%${_msg}s")

	(( _pbar_size=cols-2*block-8 ))
	(( _progress=current*100/total ))
	(( _current=current*_pbar_size ))
	(( _current=_current/total ))
	(( _total=_pbar_size-_current ))

	if [[ "${ILoveCandy}" == true ]]; then
		# First print <_dummy_block> [ o  o  o  o  o ] _progress%
		(( _motif=_pbar_size/3 ))
		(( _dummy_block=2*block+1 ))
		_dummy_block=$(printf "%${_dummy_block}s")
		_motif=$(printf "%${_motif}s")
		printf "\r${_dummy_block}${Braket_in} ${_motif// /${Cursor_not_done}}${Braket_out} ${_progress}%%"

		# Second print <title> <msg> [-----C
		_current_pair=${_current}
		(( _current=_current-1 ))
		(( _total=_total ))
		_current=$(printf "%${_current}s")
		_total=$(printf "%${_total}s")

		printf "\r ${title}${_title} ${_msg}${msg1} ${msg2} ${msg3} "
		printf "${Braket_in}${_current// /${Cursor_done}}"
		if [[ $(( _current_pair % 2)) -eq 0 ]]; then
			printf "${Cursor}"
		else
			printf "${Cursor_small}"
		fi

		# Transform the last "C" in "-"
		if [[ "${_progress}" -eq 100 ]]; then
			printf "\r ${title}${_title} ${_msg}${msg1} ${msg2} ${msg3} ${Braket_in}${_current// /${Cursor_done}}${Cursor_done}${Braket_out}\n"
		fi
	else
		_current=$(printf "%${_current}s")
		_total=$(printf "%${_total}s")
		printf "\r ${title}${_title} ${_msg}${msg1} ${msg2} ${msg3} "
		printf "${Braket_in}${_current// /${Cursor_done}}${_total// /${Cursor_not_done}}${Braket_out} ${_progress}%%"
	fi
}

############################################################
#                                                          #
############################################################

ListRetiredMachines()
{
    echo
    echo "Connecting to HTB server..."
    echo
    { # try
        curl -s --location --request GET https://www.hackthebox.com/api/v4/machine/list/retired -H "Authorization: Bearer $appkey" | jq > $machine_json_file
    } || { # catch
        echo -e "\e[31mError. Maybe your API key is incorrect or expired. Renew your API key by running htb-update.\e[0m"
        rm -rf $machine_json_file
        exit 1
    }
    echo "Done."
    echo
    echo "Calculating the number of retired machines..."
    echo
    sleep 1
    count=$(jq -r '.info | length' $machine_json_file)
    array_index_free_machines=()
    echo "Done."
    echo

    echo "ID,Name,Points,Difficulty,Is it Free?" > $table_file
    for sequence in $(seq $count)
    do
      let index=$sequence-1
      id=$(jq -r ".info[$index].id" $machine_json_file)
      name=$(jq -r ".info[$index].name" $machine_json_file)
      points=$(jq -r ".info[$index].points" $machine_json_file)
      difficultyText=$(jq -r ".info[$index].difficultyText" $machine_json_file)
      free=$(jq -r ".info[$index].free" $machine_json_file)

      # Display variables
      if [ $free = "true" ]; then
        array_index_free_machines+=($index)
      fi

      echo "$id,$name,$points,$difficultyText,$free" >> $table_file
      progressbar "Loading retired machines" $index $count
    done

    printTable ',' "$(cat $table_file)"
    rm -rf $table_file

    echo
    echo "Today, the free retired machines are: "
    echo
    for elem in "${array_index_free_machines[@]}"
    do
        id=$(jq -r ".info[$elem].id" $machine_json_file)
        name=$(jq -r ".info[$elem].name" $machine_json_file)
        points=$(jq -r ".info[$elem].points" $machine_json_file)
        difficultyText=$(jq -r ".info[$elem].difficultyText" $machine_json_file)
        free=$(jq -r ".info[$elem].free" $machine_json_file)
        echo $name
    done
    rm -rf $machine_json_file
    echo
}

############################################################
# Process the input options. Add options as needed.        #
############################################################
# Get the options
while getopts ":hlm:" option; do #When using getopts, putting : after an option character means that it requires an argument (i.e., 'i:' requires arg).
   case "${option}" in
      h) # display Help
         Help >&2
         exit 0
         ;;
      l) # Enter a command
         ListRetiredMachines >&2
         exit 0
         ;;
      m) # Enter a command
         machine_name=$OPTARG
         ;;
      : )
        echo "Missing option argument for -$OPTARG" >&2; exit 0;;
      #*  )
        #echo "Unimplemented option: -$OPTARG" >&2; exit 0;;
     \?) # Invalid option
         echo "Error: Invalid option" >&2
         ;;
   esac
done


echo
if [ ! "$machine_name" ]; then
    echo "What is the name of the machine you would like to play?"
    read machine_name
    echo
fi

{ # try
    curl -s --location --request GET "https://www.hackthebox.com/api/v4/machine/profile/$machine_name" -H "Authorization: Bearer $appkey" | jq > $machine_json_file 
    if cat $machine_json_file | grep -q "Machine not found"; then
       echo "Machine not found"
       echo
       rm -rf $machine_json_file
       exit 1
    fi
    htb_user=$(curl -s --location --request GET "https://www.hackthebox.com/api/v4/user/info" -H "Authorization: Bearer $appkey" | jq '.info.name')
} || { # catch
    echo -e "\e[31mError. Maybe your API key is incorrect or expired. Renew your API key by running htb-update.\e[0m"
    rm -rf $machine_json_file
    exit 1
}

id=$(jq -r ".info.id" $machine_json_file)
name=$(jq -r ".info.name" $machine_json_file)
ip=$(jq -r ".info.ip" $machine_json_file)
points=$(jq -r ".info.points" $machine_json_file)
rm -rf $machine_json_file

htb-spawn $id $appkey $name $ip $points $htb_user
